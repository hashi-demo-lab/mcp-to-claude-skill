import { compile } from "json-schema-to-typescript";
import { MCPTool } from "./mcp-client.js";
import { ToolCategory } from "./skill-generator.js";

export interface TypeScriptInterface {
  name: string;
  code: string;
}

/**
 * Convert a tool name to a valid TypeScript interface name
 * Examples:
 *   get_weather -> GetWeather
 *   list-files -> ListFiles
 *   read_file -> ReadFile
 */
function toolNameToInterfaceName(toolName: string): string {
  return toolName
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

/**
 * Generate TypeScript interface name for input/output
 */
function getInputInterfaceName(toolName: string): string {
  return `${toolNameToInterfaceName(toolName)}Input`;
}

function getOutputInterfaceName(toolName: string): string {
  return `${toolNameToInterfaceName(toolName)}Output`;
}

/**
 * Convert JSON Schema to TypeScript interface using json-schema-to-typescript
 */
async function jsonSchemaToTypeScript(
  schema: any,
  interfaceName: string
): Promise<string> {
  try {
    const ts = await compile(schema, interfaceName, {
      bannerComment: "",
      style: {
        bracketSpacing: true,
        printWidth: 100,
        semi: true,
        singleQuote: false,
        tabWidth: 2,
        trailingComma: "es5",
        useTabs: false,
      },
    });
    return ts;
  } catch (error) {
    console.error(`Error converting schema for ${interfaceName}:`, error);
    // Return a fallback interface
    return `export interface ${interfaceName} {\n  [key: string]: any;\n}\n`;
  }
}

/**
 * Generate TypeScript interfaces for a single MCP tool
 */
export async function generateToolInterfaces(
  tool: MCPTool
): Promise<TypeScriptInterface[]> {
  const interfaces: TypeScriptInterface[] = [];
  const inputInterfaceName = getInputInterfaceName(tool.name);

  // Generate input interface from inputSchema
  if (tool.inputSchema) {
    const inputCode = await jsonSchemaToTypeScript(
      tool.inputSchema,
      inputInterfaceName
    );
    interfaces.push({
      name: inputInterfaceName,
      code: inputCode,
    });
  }

  return interfaces;
}

/**
 * Generate all TypeScript interfaces for a list of MCP tools
 */
export async function generateAllInterfaces(
  tools: MCPTool[]
): Promise<string> {
  const allInterfaces: string[] = [];

  // Add header comment
  allInterfaces.push("/**");
  allInterfaces.push(" * Auto-generated TypeScript interfaces from MCP server");
  allInterfaces.push(" * Generated by mcp-to-claude-skill");
  allInterfaces.push(" */");
  allInterfaces.push("");

  // Generate interfaces for each tool
  for (const tool of tools) {
    const interfaces = await generateToolInterfaces(tool);

    for (const iface of interfaces) {
      allInterfaces.push(`// Interface for tool: ${tool.name}`);
      if (tool.description) {
        allInterfaces.push(`// ${tool.description}`);
      }
      allInterfaces.push(iface.code);
    }
  }

  return allInterfaces.join("\n");
}

/**
 * Generate a mapping of tool names to their interface names
 */
export function generateToolInterfaceMapping(
  tools: MCPTool[]
): Record<string, { input: string; description?: string }> {
  const mapping: Record<string, { input: string; description?: string }> = {};

  for (const tool of tools) {
    mapping[tool.name] = {
      input: getInputInterfaceName(tool.name),
      description: tool.description,
    };
  }

  return mapping;
}

/**
 * Convert tool name to PascalCase function name
 */
function toolNameToFunctionName(toolName: string): string {
  return toolNameToInterfaceName(toolName);
}

/**
 * Convert tool name to camelCase file name
 */
function toolNameToFileName(toolName: string): string {
  const parts = toolName.split(/[-_]/);
  return parts[0] + parts.slice(1).map(p => p.charAt(0).toUpperCase() + p.slice(1)).join('');
}

/**
 * Generate a complete wrapper function file for a single tool
 */
export async function generateToolWrapperFile(tool: MCPTool): Promise<string> {
  const inputInterfaceName = getInputInterfaceName(tool.name);
  const outputInterfaceName = getOutputInterfaceName(tool.name);
  const functionName = toolNameToFunctionName(tool.name);

  const lines: string[] = [];

  // Add header comment
  lines.push("/**");
  lines.push(` * ${tool.name}`);
  if (tool.description) {
    lines.push(` * ${tool.description}`);
  }
  lines.push(" * Auto-generated by mcp-to-claude-skill");
  lines.push(" */");
  lines.push("");

  // Generate input interface
  if (tool.inputSchema) {
    const inputCode = await jsonSchemaToTypeScript(tool.inputSchema, inputInterfaceName);
    lines.push(inputCode);
  } else {
    lines.push(`export interface ${inputInterfaceName} {`);
    lines.push(`  [key: string]: any;`);
    lines.push(`}`);
    lines.push("");
  }

  // Generate output interface (placeholder - MCP doesn't provide output schemas yet)
  lines.push(`export interface ${outputInterfaceName} {`);
  lines.push(`  content?: Array<{`);
  lines.push(`    type: string;`);
  lines.push(`    text?: string;`);
  lines.push(`    [key: string]: any;`);
  lines.push(`  }>;`);
  lines.push(`  isError?: boolean;`);
  lines.push(`  [key: string]: any;`);
  lines.push(`}`);
  lines.push("");

  // Generate wrapper function
  lines.push(`/**`);
  if (tool.description) {
    lines.push(` * ${tool.description}`);
  }
  lines.push(` */`);
  lines.push(`export async function ${functionName}(`);
  lines.push(`  input: ${inputInterfaceName}`);
  lines.push(`): Promise<${outputInterfaceName}> {`);
  lines.push(`  // This is a placeholder implementation`);
  lines.push(`  // In a real implementation, this would call the MCP server`);
  lines.push(`  throw new Error("MCP tool wrapper not yet implemented. Use MCP server directly.");`);
  lines.push(`}`);
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate TypeScript interfaces organized by category
 */
export async function generateCategorizedInterfaces(
  categories: ToolCategory[]
): Promise<Map<string, string>> {
  const categoryMap = new Map<string, string>();

  for (const category of categories) {
    const allInterfaces: string[] = [];

    // Add header comment
    allInterfaces.push("/**");
    allInterfaces.push(` * ${category.name} - ${category.description}`);
    allInterfaces.push(" * Auto-generated TypeScript interfaces from MCP server");
    allInterfaces.push(" * Generated by mcp-to-claude-skill");
    allInterfaces.push(" */");
    allInterfaces.push("");

    // Generate interfaces for each tool in this category
    for (const tool of category.tools) {
      const interfaces = await generateToolInterfaces(tool);

      for (const iface of interfaces) {
        allInterfaces.push(`// Interface for tool: ${tool.name}`);
        if (tool.description) {
          allInterfaces.push(`// ${tool.description}`);
        }
        allInterfaces.push(iface.code);
      }
    }

    categoryMap.set(category.directory, allInterfaces.join("\n"));
  }

  return categoryMap;
}

/**
 * Generate individual wrapper files organized by category
 * Returns a map of category -> tool files
 */
export async function generateCategorizedWrappers(
  categories: ToolCategory[]
): Promise<Map<string, Map<string, string>>> {
  const categoryMap = new Map<string, Map<string, string>>();

  for (const category of categories) {
    const toolFiles = new Map<string, string>();

    // Generate a file for each tool
    for (const tool of category.tools) {
      const fileName = toolNameToFileName(tool.name);
      const fileContent = await generateToolWrapperFile(tool);
      toolFiles.set(fileName, fileContent);
    }

    categoryMap.set(category.directory, toolFiles);
  }

  return categoryMap;
}

/**
 * Generate index.ts barrel export for a category
 */
export function generateCategoryIndex(tools: MCPTool[]): string {
  const lines: string[] = [];

  lines.push("/**");
  lines.push(" * Auto-generated barrel export");
  lines.push(" * Generated by mcp-to-claude-skill");
  lines.push(" */");
  lines.push("");

  // Export all tools
  for (const tool of tools) {
    const fileName = toolNameToFileName(tool.name);
    lines.push(`export * from "./${fileName}.js";`);
  }
  lines.push("");

  return lines.join("\n");
}
