import { compile } from "json-schema-to-typescript";
import { MCPTool } from "./mcp-client.js";
import { ToolCategory } from "./skill-generator.js";

export interface TypeScriptInterface {
  name: string;
  code: string;
}

/**
 * Convert a tool name to a valid TypeScript interface name
 * Examples:
 *   get_weather -> GetWeather
 *   list-files -> ListFiles
 *   read_file -> ReadFile
 */
function toolNameToInterfaceName(toolName: string): string {
  return toolName
    .split(/[-_]/)
    .map((part) => part.charAt(0).toUpperCase() + part.slice(1))
    .join("");
}

/**
 * Generate TypeScript interface name for input/output
 */
function getInputInterfaceName(toolName: string): string {
  return `${toolNameToInterfaceName(toolName)}Input`;
}

function getOutputInterfaceName(toolName: string): string {
  return `${toolNameToInterfaceName(toolName)}Output`;
}

/**
 * Convert JSON Schema to TypeScript interface using json-schema-to-typescript
 */
async function jsonSchemaToTypeScript(
  schema: any,
  interfaceName: string
): Promise<string> {
  try {
    const ts = await compile(schema, interfaceName, {
      bannerComment: "",
      style: {
        bracketSpacing: true,
        printWidth: 100,
        semi: true,
        singleQuote: false,
        tabWidth: 2,
        trailingComma: "es5",
        useTabs: false,
      },
    });
    return ts;
  } catch (error) {
    console.error(`Error converting schema for ${interfaceName}:`, error);
    // Return a fallback interface
    return `export interface ${interfaceName} {\n  [key: string]: any;\n}\n`;
  }
}

/**
 * Generate TypeScript interfaces for a single MCP tool
 */
export async function generateToolInterfaces(
  tool: MCPTool
): Promise<TypeScriptInterface[]> {
  const interfaces: TypeScriptInterface[] = [];
  const inputInterfaceName = getInputInterfaceName(tool.name);

  // Generate input interface from inputSchema
  if (tool.inputSchema) {
    const inputCode = await jsonSchemaToTypeScript(
      tool.inputSchema,
      inputInterfaceName
    );
    interfaces.push({
      name: inputInterfaceName,
      code: inputCode,
    });
  }

  return interfaces;
}

/**
 * Generate all TypeScript interfaces for a list of MCP tools
 */
export async function generateAllInterfaces(
  tools: MCPTool[]
): Promise<string> {
  const allInterfaces: string[] = [];

  // Add header comment
  allInterfaces.push("/**");
  allInterfaces.push(" * Auto-generated TypeScript interfaces from MCP server");
  allInterfaces.push(" * Generated by mcp-to-claude-skill");
  allInterfaces.push(" */");
  allInterfaces.push("");

  // Generate interfaces for each tool
  for (const tool of tools) {
    const interfaces = await generateToolInterfaces(tool);

    for (const iface of interfaces) {
      allInterfaces.push(`// Interface for tool: ${tool.name}`);
      if (tool.description) {
        allInterfaces.push(`// ${tool.description}`);
      }
      allInterfaces.push(iface.code);
    }
  }

  return allInterfaces.join("\n");
}

/**
 * Generate a mapping of tool names to their interface names
 */
export function generateToolInterfaceMapping(
  tools: MCPTool[]
): Record<string, { input: string; description?: string }> {
  const mapping: Record<string, { input: string; description?: string }> = {};

  for (const tool of tools) {
    mapping[tool.name] = {
      input: getInputInterfaceName(tool.name),
      description: tool.description,
    };
  }

  return mapping;
}

/**
 * Generate TypeScript interfaces organized by category
 */
export async function generateCategorizedInterfaces(
  categories: ToolCategory[]
): Promise<Map<string, string>> {
  const categoryMap = new Map<string, string>();

  for (const category of categories) {
    const allInterfaces: string[] = [];

    // Add header comment
    allInterfaces.push("/**");
    allInterfaces.push(` * ${category.name} - ${category.description}`);
    allInterfaces.push(" * Auto-generated TypeScript interfaces from MCP server");
    allInterfaces.push(" * Generated by mcp-to-claude-skill");
    allInterfaces.push(" */");
    allInterfaces.push("");

    // Generate interfaces for each tool in this category
    for (const tool of category.tools) {
      const interfaces = await generateToolInterfaces(tool);

      for (const iface of interfaces) {
        allInterfaces.push(`// Interface for tool: ${tool.name}`);
        if (tool.description) {
          allInterfaces.push(`// ${tool.description}`);
        }
        allInterfaces.push(iface.code);
      }
    }

    categoryMap.set(category.directory, allInterfaces.join("\n"));
  }

  return categoryMap;
}
